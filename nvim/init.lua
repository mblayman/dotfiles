-- -- Neovim LSP completion source
-- --
-- -- This plugin provides more completion capabilities
-- -- that the Neovim client can expose to LSP servers.
-- -- The LSP server can then enrich what the completion engine can do.
-- Plug "hrsh7th/cmp-nvim-lsp"
--
-- -- Neovim completion engine
-- --
-- -- This plugin is the core completion engine that can be fed completions
-- -- from sources like an LSP server or a snippet plugin.
-- Plug "hrsh7th/nvim-cmp"
--
-- -- LSP progress UI
-- --
-- -- This plugin adds a bit of UI above the status line to show the progress
-- -- state of an LSP server if that state is available.
-- Plug "j-hui/fidget.nvim"
--
-- -- Include other LSP sources
-- --
-- -- This plugin makes it possible to use external tools and treat them
-- -- as sources that will be plugged into the LSP ecosystem.
-- -- By using this in combination with Mason, I can add tools like Black
-- -- without installing a dedicated Black plugin.
-- Plug "jose-elias-alvarez/null-ls.nvim"
--
-- -- Snippet engine
-- --
-- -- This is tool for doing fancy autocomplete of common activities
-- -- (e.g., making a function with a standard docstring)
-- --
-- -- TODO: learn more about this later. For now, nvim-cmp requires a snippet
-- -- engine for some reason and that's the only reason why I've included
-- -- this plugin.
-- Plug "L3MON4D3/LuaSnip"
--
-- -- The configuration plugin for Neovim LSP integration
-- --
-- -- This plugin provides configuration that integrates Neovim (an LSP client)
-- -- with one of the supported LSP servers listed with this plugin.
-- Plug "neovim/nvim-lspconfig"
--
-- -- LuaSnip completion source connector
-- --
-- -- This plugin bridges the LuaSnip snippet engine
-- -- as a source for the Neovim completion engine.
-- Plug "saadparwaiz1/cmp_luasnip"
--
-- -- Neovim LSP package manager
-- --
-- -- This plugin has the job of fetching LSP servers and clients
-- -- so that I don't have to. I get to specify something like "pyright"
-- -- and mason.nvim does the rest.
-- --
-- -- mason.nvim does *not* do any configuration of LSP clients and servers.
-- -- That configuration is delegating to other plugins.
-- Plug "williamboman/mason.nvim"
--
-- -- Bridge between mason.nvim and lspconfig
-- --
-- -- This plugin is a compatibility layer that allows mason-installed LSP servers
-- -- to have easier configuration with the lspconfig plugin.
-- Plug "williamboman/mason-lspconfig.nvim"
--
-- vim.call("plug#end")
-- Global configuration
--
-- Do this stuff before loading plugins so that plugins have a consistent behavior.
-- Set the leader key to spacebar.
--
-- This is, hands down, one of Vim's superpowers that is possible
-- because of modal editing.
vim.g.mapleader = " "
vim.g.maplocalleader = " "

vim.g.rg_command = "rg --vimgrep -S"

require("mblayman/options")
require("mblayman/keymaps")
require("mblayman/lazy_bootstrap")
require("mblayman/lazy_init")

-- -- LSP settings.
--
-- -- This autocommand group is for attaching a format on save option
-- -- to each buffer.
-- local augroup = vim.api.nvim_create_augroup("LspFormatting", {})
--
-- --  This function gets run when an LSP connects to a particular buffer.
-- local on_attach = function(client, bufnr)
--   local nmap = function(keys, func, desc)
--     if desc then desc = "LSP: " .. desc end
--
--     vim.keymap.set("n", keys, func, {buffer = bufnr, desc = desc})
--   end
--
--   nmap("<leader>rn", vim.lsp.buf.rename, "[R]e[n]ame")
--   nmap("<leader>ca", vim.lsp.buf.code_action, "[C]ode [A]ction")
--
--   nmap("gd", vim.lsp.buf.definition, "[G]oto [D]efinition")
--   nmap("gr", require("telescope.builtin").lsp_references, "[G]oto [R]eferences")
--   nmap("gI", vim.lsp.buf.implementation, "[G]oto [I]mplementation")
--   nmap("<leader>D", vim.lsp.buf.type_definition, "Type [D]efinition")
--   nmap("<leader>ds", require("telescope.builtin").lsp_document_symbols,
--        "[D]ocument [S]ymbols")
--   nmap("<leader>ws", require("telescope.builtin").lsp_dynamic_workspace_symbols,
--        "[W]orkspace [S]ymbols")
--
--   -- See `:help K` for why this keymap
--   nmap("K", vim.lsp.buf.hover, "Hover Documentation")
--   nmap("<C-k>", vim.lsp.buf.signature_help, "Signature Documentation")
--
--   -- Lesser used LSP functionality
--   nmap("gD", vim.lsp.buf.declaration, "[G]oto [D]eclaration")
--
--   -- Create a command `:Format` local to the LSP buffer
--   vim.api.nvim_buf_create_user_command(bufnr, "Format",
--                                        function(_) vim.lsp.buf.format() end,
--                                        {desc = "Format current buffer with LSP"})
--
--   -- Enable format on write.
--   if client.supports_method("textDocument/formatting") then
--     vim.api.nvim_clear_autocmds({group = augroup, buffer = bufnr})
--     vim.api.nvim_create_autocmd("BufWritePre", {
--       group = augroup,
--       buffer = bufnr,
--       callback = function() vim.lsp.buf.format({bufnr = bufnr}) end,
--     })
--   end
-- end
--
-- local servers = {
--   "clangd", -- C
--   "gopls", -- Go
--   "pyright", -- Python
--   "lua_ls", -- Lua
--   "zls", -- Zig
-- }
--
-- require("mason").setup()
-- require("mason-lspconfig").setup({
--   -- Get the desired LSP servers automatically
--   -- without needing a manual install action.
--   ensure_installed = servers,
-- })
--
-- -- LSP server configuration
-- --
-- -- Most of these language configurations will only need to call `setup`,
-- -- but I'm not doing that in a loop because each could have a unique setup.
-- local lspconfig = require("lspconfig")
--
-- -- Create the expanded capabilities set so that the LSP servers will know
-- -- that the Neovim client can do more.
-- local capabilities = vim.lsp.protocol.make_client_capabilities()
-- capabilities = require("cmp_nvim_lsp").default_capabilities(capabilities)
--
-- -- C
-- lspconfig.clangd.setup({capabilities = capabilities, on_attach = on_attach})
--
-- -- Go
-- lspconfig.gopls.setup({capabilities = capabilities, on_attach = on_attach})
--
-- -- Lua
-- local runtime_path = vim.split(package.path, ";")
-- table.insert(runtime_path, "lua/?.lua")
-- table.insert(runtime_path, "lua/?/init.lua")
--
-- lspconfig.lua_ls.setup({
--   capabilities = capabilities,
--   on_attach = on_attach,
--   settings = {
--     Lua = {
--       format = {enable = false},
--       runtime = {
--         -- Tell the language server which version of Lua you're using (most likely LuaJIT)
--         version = "LuaJIT",
--         -- Setup your lua path
--         path = runtime_path,
--       },
--       diagnostics = {globals = {"vim"}},
--       workspace = {
--         -- Tell the language server to stop prompting me
--         -- to configure my project as a LOVE project.
--         checkThirdParty = false,
--         library = vim.api.nvim_get_runtime_file("", true),
--       },
--       -- Do not send telemetry data containing a randomized but unique identifier
--       telemetry = {enable = false},
--     },
--   },
-- })
--
-- -- Python
-- lspconfig.pyright.setup({capabilities = capabilities, on_attach = on_attach})
--
-- -- Zig
-- lspconfig.zls.setup({capabilities = capabilities, on_attach = on_attach})
--
-- -- Enable other tools that can be used by LSP
--
-- local null_ls = require("null-ls")
--
-- null_ls.setup({
--   sources = {
--     null_ls.builtins.formatting.lua_format, -- Lua
--     null_ls.builtins.formatting.black, -- Python
--     null_ls.builtins.formatting.isort, -- Python
--   },
--   on_attach = on_attach,
-- })
--
-- -- Enable LSP progress UI
-- require("fidget").setup({})
--
-- -- Completion engine (nvim-cmp)
-- --
-- -- To make use of all the cool LSP server stuff,
-- -- nvim-cmp needs to be configured to use the LSP as a source.
-- local cmp = require "cmp"
-- local luasnip = require "luasnip"
--
-- cmp.setup({
--   -- Tell nvim-cmp how to expand snippets.
--   snippet = {expand = function(args) luasnip.lsp_expand(args.body) end},
--   -- Set the key mappings for the completion engine to track.
--   mapping = cmp.mapping.preset.insert({
--     -- TODO: These mappings with Ctrl do not seem to be working.
--     ["<C-d>"] = cmp.mapping.scroll_docs(-4),
--     ["<C-f>"] = cmp.mapping.scroll_docs(4),
--     ["<C-Space>"] = cmp.mapping.complete(),
--     ["<CR>"] = cmp.mapping.confirm({
--       behavior = cmp.ConfirmBehavior.Replace,
--       select = false,
--     }),
--     ["<Tab>"] = cmp.mapping(function(fallback)
--       if cmp.visible() then
--         cmp.select_next_item()
--       elseif luasnip.expand_or_jumpable() then
--         luasnip.expand_or_jump()
--       else
--         fallback()
--       end
--     end, {"i", "s"}),
--     ["<S-Tab>"] = cmp.mapping(function(fallback)
--       if cmp.visible() then
--         cmp.select_prev_item()
--       elseif luasnip.jumpable(-1) then
--         luasnip.jump(-1)
--       else
--         fallback()
--       end
--     end, {"i", "s"}),
--   }),
--   -- Specify the completion sources.
--   sources = {{name = "nvim_lsp"}, {name = "luasnip"}},
-- })

-- For some reason, Neovim is not recognizing the templ file extension.
-- There is probably a better way to do this, but this is fine for now.
vim.cmd [[autocmd BufNewFile,BufRead *.templ set ft=templ]]
